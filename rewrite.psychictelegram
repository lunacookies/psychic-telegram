fn main() int {
    tests();
}

struct str { data *char, len int }
struct range { start int, len int }

fn str_new(nullterminated *char) str {
    let lenprefixed str;
    lenprefixed.data = nullterminated;
    lenprefixed.len = strlen(nullterminated);
    return lenprefixed;
}

fn str_empty() str {
    let s str;
    s.data = 0;
    s.len = 0;
    return s;
}

fn str_equal(s1 str, nullterminated *char) bool {
    let s2 str = str_new(nullterminated);
    if s1.len != s2.len { return false; }
    let i int = 0;
    for {
        if i > s1.len { break; }
        let c1 char = *(s1.data + i);
        let c2 char = *(s2.data + i);
        if c1 != c2 { return false; }
        i += 1;
    }
    return true;
}

fn str_print(s str) {
    let i int = 0;
    for {
        if i == s.len { break; }
        printf("%c", *(s.data + i));
        i += 1;
    }
}

fn range_equal(r range, start int, len int) bool {
    return r.start == start && r.len == len;
}

fn range_print(r range) {
    printf("\x1B[92m%d\x1B[0m..\x1B[92m%d\x1B[0m", r.start, r.start + r.len);
}

fn tests() {
    printf("--> LEXER\n"); test_lexer();
    printf("--> SYNTAX\n"); test_syntax();
}

struct lexer { text str, range range }
struct token { kind char, range range }

let SK_EOF = 0;
let SK_ERROR = 1;
let SK_WS = 2;
let SK_NUMBER = 3;
let SK_IDENT = 4;
let SK_STRING = 5;
let SK_RAWSTRING = 6;
let SK_CHAR = 7;
let SK_DOT = 8;
let SK_COLON = 9;
let SK_COMMA = 10;
let SK_SEMI = 11;
let SK_LPAREN = 12;
let SK_RPAREN = 13;
let SK_LBRACE = 14;
let SK_RBRACE = 15;
let SK_PLUS = 16;
let SK_HYPEN = 17;
let SK_STAR = 18;
let SK_SLASH = 19;
let SK_EQUAL = 20;
let SK_BANG = 21;
let SK_PRETZEL = 22;
let SK_PIPE = 23;
let SK_LT = 24;
let SK_GT = 25;
let SK_FNKW = 26;
let SK_STRUCTKW = 27;
let SK_LETKW = 28;
let SK_IFKW = 29;
let SK_FORKW = 30;
let SK_BREAKKW = 31;
let SK_RETURNKW = 32;
let SK_COMMENT = 33;

let SK_ROOT = -1;
let SK_FUNCTION = -2;

fn syntaxkind_print(k char) {
    printf("\x1B[94m");
    str_print(syntaxkind_format(k));
    printf("\x1B[0m");
}

fn syntaxkind_format(k char) str {
    if k == 0 { return str_new("EOF"); }
    if k == 1 { return str_new("ERROR"); }
    if k == 2 { return str_new("WS"); }
    if k == 3 { return str_new("NUMBER"); }
    if k == 4 { return str_new("IDENT"); }
    if k == 5 { return str_new("STRING"); }
    if k == 6 { return str_new("RAWSTRING"); }
    if k == 7 { return str_new("CHAR"); }
    if k == 8 { return str_new("DOT"); }
    if k == 9 { return str_new("COLON"); }
    if k == 10 { return str_new("COMMA"); }
    if k == 11 { return str_new("SEMI"); }
    if k == 12 { return str_new("LPAREN"); }
    if k == 13 { return str_new("RPAREN"); }
    if k == 14 { return str_new("LBRACE"); }
    if k == 15 { return str_new("RBRACE"); }
    if k == 16 { return str_new("PLUS"); }
    if k == 17 { return str_new("HYPEN"); }
    if k == 18 { return str_new("STAR"); }
    if k == 19 { return str_new("SLASH"); }
    if k == 20 { return str_new("EQUAL"); }
    if k == 21 { return str_new("BANG"); }
    if k == 22 { return str_new("PRETZEL"); }
    if k == 23 { return str_new("PIPE"); }
    if k == 24 { return str_new("LT"); }
    if k == 25 { return str_new("GT"); }
    if k == 26 { return str_new("FNKW"); }
    if k == 27 { return str_new("STRUCTKW"); }
    if k == 28 { return str_new("LETKW"); }
    if k == 29 { return str_new("IFKW"); }
    if k == 30 { return str_new("FORKW"); }
    if k == 31 { return str_new("BREAKKW"); }
    if k == 32 { return str_new("RETURNKW"); }
    if k == 33 { return str_new("COMMENT"); }
    if k == -1 { return str_new("ROOT"); }
    if k == -2 { return str_new("FUNCTION"); }

    printf("bad syntaxkind\n");
    exit(1);
}

fn lexer_new(text str) lexer {
    let l lexer;
    l.text = text;
    l.range.start = 0;
    l.range.len = 0;
    return l;
}

fn lexer_next(l *lexer) token {
    if lexer_ateof(l) {
        let t token;
        t.kind = SK_EOF;
        t.range.start = 0;
        t.range.len = 0;
        return t;
    }

    if lexer_atws(l) { return lexer_ws(l); }
    if lexer_atdigit(l) { return lexer_number(l); }
    if lexer_atalpha(l) { return lexer_ident(l); }
    if lexer_current(l) == '"' { return lexer_delimited(l, '"', SK_STRING); }
    if lexer_current(l) == 39 { return lexer_delimited(l, 39, SK_CHAR); }
    if lexer_current(l) == '\\' { return lexer_rawstring(l); }
    if lexer_current(l) == '#' { return lexer_comment(l); }

    if lexer_current(l) == '.' {
        l->range.len += 1;
        return lexer_emit(l, SK_DOT);
    }
    if lexer_current(l) == ':' {
        l->range.len += 1;
        return lexer_emit(l, SK_COLON);
    }
    if lexer_current(l) == ',' {
        l->range.len += 1;
        return lexer_emit(l, SK_COMMA);
    }
    if lexer_current(l) == ';' {
        l->range.len += 1;
        return lexer_emit(l, SK_SEMI);
    }
    if lexer_current(l) == '(' {
        l->range.len += 1;
        return lexer_emit(l, SK_LPAREN);
    }
    if lexer_current(l) == ')' {
        l->range.len += 1;
        return lexer_emit(l, SK_RPAREN);
    }
    if lexer_current(l) == '{' {
        l->range.len += 1;
        return lexer_emit(l, SK_LBRACE);
    }
    if lexer_current(l) == '}' {
        l->range.len += 1;
        return lexer_emit(l, SK_RBRACE);
    }
    if lexer_current(l) == '+' {
        l->range.len += 1;
        return lexer_emit(l, SK_PLUS);
    }
    if lexer_current(l) == '-' {
        l->range.len += 1;
        return lexer_emit(l, SK_HYPEN);
    }
    if lexer_current(l) == '*' {
        l->range.len += 1;
        return lexer_emit(l, SK_STAR);
    }
    if lexer_current(l) == '/' {
        l->range.len += 1;
        return lexer_emit(l, SK_SLASH);
    }
    if lexer_current(l) == '=' {
        l->range.len += 1;
        return lexer_emit(l, SK_EQUAL);
    }
    if lexer_current(l) == '!' {
        l->range.len += 1;
        return lexer_emit(l, SK_BANG);
    }
    if lexer_current(l) == '&' {
        l->range.len += 1;
        return lexer_emit(l, SK_PRETZEL);
    }
    if lexer_current(l) == '|' {
        l->range.len += 1;
        return lexer_emit(l, SK_PIPE);
    }
    if lexer_current(l) == '<' {
        l->range.len += 1;
        return lexer_emit(l, SK_LT);
    }
    if lexer_current(l) == '>' {
        l->range.len += 1;
        return lexer_emit(l, SK_GT);
    }

    l->range.len += 1;
    return lexer_emit(l, SK_ERROR);
}

fn lexer_ws(l *lexer) token {
    for {
        if lexer_ateof(l) || !lexer_atws(l) { break; }
        l->range.len += 1;
    }
    return lexer_emit(l, SK_WS);
}

fn lexer_number(l *lexer) token {
    for {
        if lexer_ateof(l) || !lexer_atdigit(l) { break; }
        l->range.len += 1;
    }
    return lexer_emit(l, SK_NUMBER);
}

fn lexer_ident(l *lexer) token {
    for {
        if lexer_ateof(l) ||
            !(
                lexer_atalpha(l) ||
                lexer_atdigit(l) ||
                lexer_current(l) == '_'
            ) { break; }
        l->range.len += 1;
    }

    let text str = lexer_text(l);
    if str_equal(text, "fn") { return lexer_emit(l, SK_FNKW); }
    if str_equal(text, "struct") { return lexer_emit(l, SK_STRUCTKW); }
    if str_equal(text, "let") { return lexer_emit(l, SK_LETKW); }
    if str_equal(text, "if") { return lexer_emit(l, SK_IFKW); }
    if str_equal(text, "for") { return lexer_emit(l, SK_FORKW); }
    if str_equal(text, "break") { return lexer_emit(l, SK_BREAKKW); }
    if str_equal(text, "return") { return lexer_emit(l, SK_RETURNKW); }

    return lexer_emit(l, SK_IDENT);
}

fn lexer_delimited(l *lexer, delimiter char, kind char) token {
    l->range.len += 1;
    for {
        let inescape bool = !lexer_ateof(l) && lexer_current(l) == '\\';
        if inescape { l->range.len += 1; }

        if lexer_ateof(l) { return lexer_emit(l, SK_ERROR); }
        if lexer_current(l) == '\n' { return lexer_emit(l, SK_ERROR); }
        if lexer_current(l) == delimiter && !inescape { break; }
        l->range.len += 1;
    }
    l->range.len += 1;
    return lexer_emit(l, kind);
}

fn lexer_rawstring(l *lexer) token {
    for {
        if lexer_ateof(l) || lexer_current(l) == '\n' { break; }
        l->range.len += 1;
    }
    return lexer_emit(l, SK_RAWSTRING);
}

fn lexer_comment(l *lexer) token {
    for {
        if lexer_ateof(l) || lexer_current(l) == '\n' { break; }
        l->range.len += 1;
    }
    return lexer_emit(l, SK_COMMENT);
}

fn lexer_atws(l *lexer) bool {
    return lexer_current(l) == ' ' || lexer_current(l) == '\n';
}

fn lexer_atdigit(l *lexer) bool {
    return lexer_current(l) >= '0' && lexer_current(l) <= '9';
}

fn lexer_atalpha(l *lexer) bool {
    return lexer_current(l) >= 'a' && lexer_current(l) <= 'z' ||
        lexer_current(l) >= 'A' && lexer_current(l) <= 'Z';
}

fn lexer_emit(l *lexer, kind char) token {
    let t token;
    t.kind = kind;
    t.range = l->range;

    l->range.start += l->range.len;
    l->range.len = 0;

    return t;
}

fn lexer_text(l *lexer) str {
    let s str;
    s.data = l->text.data + l->range.start;
    s.len = l->range.len;
    return s;
}

fn lexer_current(l *lexer) char {
    assert(!lexer_ateof(l));
    return *(l->text.data + l->range.start + l->range.len);
}

fn lexer_ateof(l *lexer) bool {
    return l->range.start + l->range.len >= l->text.len;
}

fn token_equal(t token, kind char, start int, len int) bool {
    return range_equal(t.range, start, len) && t.kind == kind;
}

fn token_print(t token) {
    printf("{ ");
    syntaxkind_print(t.kind);
    printf(", ");
    range_print(t.range);
    printf(" }\n");
}

fn test_lexer() {
    printf("    test empty\n"); test_lexer_empty();
    printf("    test ws\n"); test_lexer_ws();
    printf("    test number\n"); test_lexer_number();
    printf("    test numbers\n"); test_lexer_numbers();
    printf("    test idents\n"); test_lexer_idents();
    printf("    test strings\n"); test_lexer_strings();
    printf("    test no_multiline_strings\n"); test_lexer_no_multiline_strings();
    printf("    test unclosed_string\n"); test_lexer_unclosed_string();
    printf("    test no_escape_newline\n"); test_lexer_no_escape_newline();
    printf("    test char\n"); test_lexer_char();
    printf("    test symbols\n"); test_lexer_symbols();
    printf("    test keywords\n"); test_lexer_keywords();
    printf("    test comments\n"); test_lexer_comments();
    printf("    test rawstrings\n"); test_lexer_rawstrings();
}

fn test_lexer_empty() {
    let l lexer = lexer_new(str_empty());
    assert(token_equal(lexer_next(&l), SK_EOF, 0, 0));
}

fn test_lexer_ws() {
    let l lexer = lexer_new(str_new("  \n \n"));
    assert(token_equal(lexer_next(&l), SK_WS, 0, 5));
    assert(token_equal(lexer_next(&l), SK_EOF, 0, 0));
}

fn test_lexer_number() {
    let l lexer = lexer_new(str_new("92"));
    assert(token_equal(lexer_next(&l), SK_NUMBER, 0, 2));
    assert(token_equal(lexer_next(&l), SK_EOF, 0, 0));
}

fn test_lexer_numbers() {
    let l lexer = lexer_new(str_new("1 2\n33 44"));
    assert(token_equal(lexer_next(&l), SK_NUMBER, 0, 1));
    assert(token_equal(lexer_next(&l), SK_WS, 1, 1));
    assert(token_equal(lexer_next(&l), SK_NUMBER, 2, 1));
    assert(token_equal(lexer_next(&l), SK_WS, 3, 1));
    assert(token_equal(lexer_next(&l), SK_NUMBER, 4, 2));
    assert(token_equal(lexer_next(&l), SK_WS, 6, 1));
    assert(token_equal(lexer_next(&l), SK_NUMBER, 7, 2));
    assert(token_equal(lexer_next(&l), SK_EOF, 0, 0));
}

fn test_lexer_idents() {
    let l lexer = lexer_new(str_new("abc d EFG_H fnbAR01if6"));
    assert(token_equal(lexer_next(&l), SK_IDENT, 0, 3));
    assert(token_equal(lexer_next(&l), SK_WS, 3, 1));
    assert(token_equal(lexer_next(&l), SK_IDENT, 4, 1));
    assert(token_equal(lexer_next(&l), SK_WS, 5, 1));
    assert(token_equal(lexer_next(&l), SK_IDENT, 6, 5));
    assert(token_equal(lexer_next(&l), SK_WS, 11, 1));
    assert(token_equal(lexer_next(&l), SK_IDENT, 12, 10));
    assert(token_equal(lexer_next(&l), SK_EOF, 0, 0));
}

fn test_lexer_strings() {
    let l lexer = lexer_new(str_new("\"\" \"?\" \"\\n\" \"\\\"\""));
    assert(token_equal(lexer_next(&l), SK_STRING, 0, 2));
    assert(token_equal(lexer_next(&l), SK_WS, 2, 1));
    assert(token_equal(lexer_next(&l), SK_STRING, 3, 3));
    assert(token_equal(lexer_next(&l), SK_WS, 6, 1));
    assert(token_equal(lexer_next(&l), SK_STRING, 7, 4));
    assert(token_equal(lexer_next(&l), SK_WS, 11, 1));
    assert(token_equal(lexer_next(&l), SK_STRING, 12, 4));
    assert(token_equal(lexer_next(&l), SK_EOF, 0, 0));
}

fn test_lexer_no_multiline_strings() {
    let l lexer = lexer_new(str_new("\"a\nb\""));
    assert(token_equal(lexer_next(&l), SK_ERROR, 0, 2));
    assert(token_equal(lexer_next(&l), SK_WS, 2, 1));
    assert(token_equal(lexer_next(&l), SK_IDENT, 3, 1));
    assert(token_equal(lexer_next(&l), SK_ERROR, 4, 1));
    assert(token_equal(lexer_next(&l), SK_EOF, 0, 0));
}

fn test_lexer_unclosed_string() {
    let l lexer = lexer_new(str_new("\"foo"));
    assert(token_equal(lexer_next(&l), SK_ERROR, 0, 4));
    assert(token_equal(lexer_next(&l), SK_EOF, 0, 0));
}

fn test_lexer_no_escape_newline() {
    let l lexer = lexer_new(str_new("\"\\\n92"));
    assert(token_equal(lexer_next(&l), SK_ERROR, 0, 2));
    assert(token_equal(lexer_next(&l), SK_WS, 2, 1));
    assert(token_equal(lexer_next(&l), SK_NUMBER, 3, 2));
    assert(token_equal(lexer_next(&l), SK_EOF, 0, 0));
}

fn test_lexer_char() {
    let l lexer = lexer_new(str_new("'a' '\\n' '\\\\' 'foo' '\\''"));
    assert(token_equal(lexer_next(&l), SK_CHAR, 0, 3));
    assert(token_equal(lexer_next(&l), SK_WS, 3, 1));
    assert(token_equal(lexer_next(&l), SK_CHAR, 4, 4));
    assert(token_equal(lexer_next(&l), SK_WS, 8, 1));
    assert(token_equal(lexer_next(&l), SK_CHAR, 9, 4));
    assert(token_equal(lexer_next(&l), SK_WS, 13, 1));
    assert(token_equal(lexer_next(&l), SK_CHAR, 14, 5));
    assert(token_equal(lexer_next(&l), SK_WS, 19, 1));
    assert(token_equal(lexer_next(&l), SK_CHAR, 20, 4));
    assert(token_equal(lexer_next(&l), SK_EOF, 0, 0));
}

fn test_lexer_symbols() {
    let l lexer = lexer_new(str_new(".:,;(){}+-*/=!&|<>"));
    assert(token_equal(lexer_next(&l), SK_DOT, 0, 1));
    assert(token_equal(lexer_next(&l), SK_COLON, 1, 1));
    assert(token_equal(lexer_next(&l), SK_COMMA, 2, 1));
    assert(token_equal(lexer_next(&l), SK_SEMI, 3, 1));
    assert(token_equal(lexer_next(&l), SK_LPAREN, 4, 1));
    assert(token_equal(lexer_next(&l), SK_RPAREN, 5, 1));
    assert(token_equal(lexer_next(&l), SK_LBRACE, 6, 1));
    assert(token_equal(lexer_next(&l), SK_RBRACE, 7, 1));
    assert(token_equal(lexer_next(&l), SK_PLUS, 8, 1));
    assert(token_equal(lexer_next(&l), SK_HYPEN, 9, 1));
    assert(token_equal(lexer_next(&l), SK_STAR, 10, 1));
    assert(token_equal(lexer_next(&l), SK_SLASH, 11, 1));
    assert(token_equal(lexer_next(&l), SK_EQUAL, 12, 1));
    assert(token_equal(lexer_next(&l), SK_BANG, 13, 1));
    assert(token_equal(lexer_next(&l), SK_PRETZEL, 14, 1));
    assert(token_equal(lexer_next(&l), SK_PIPE, 15, 1));
    assert(token_equal(lexer_next(&l), SK_LT, 16, 1));
    assert(token_equal(lexer_next(&l), SK_GT, 17, 1));
    assert(token_equal(lexer_next(&l), SK_EOF, 0, 0));
}

fn test_lexer_keywords() {
    let l lexer = lexer_new(str_new("fn struct let if for break return"));
    assert(token_equal(lexer_next(&l), SK_FNKW, 0, 2));
    assert(token_equal(lexer_next(&l), SK_WS, 2, 1));
    assert(token_equal(lexer_next(&l), SK_STRUCTKW, 3, 6));
    assert(token_equal(lexer_next(&l), SK_WS, 9, 1));
    assert(token_equal(lexer_next(&l), SK_LETKW, 10, 3));
    assert(token_equal(lexer_next(&l), SK_WS, 13, 1));
    assert(token_equal(lexer_next(&l), SK_IFKW, 14, 2));
    assert(token_equal(lexer_next(&l), SK_WS, 16, 1));
    assert(token_equal(lexer_next(&l), SK_FORKW, 17, 3));
    assert(token_equal(lexer_next(&l), SK_WS, 20, 1));
    assert(token_equal(lexer_next(&l), SK_BREAKKW, 21, 5));
    assert(token_equal(lexer_next(&l), SK_WS, 26, 1));
    assert(token_equal(lexer_next(&l), SK_RETURNKW, 27, 6));
    assert(token_equal(lexer_next(&l), SK_EOF, 0, 0));
}

fn test_lexer_comments() {
    let l lexer = lexer_new(str_new("# hello\n123#456"));
    assert(token_equal(lexer_next(&l), SK_COMMENT, 0, 7));
    assert(token_equal(lexer_next(&l), SK_WS, 7, 1));
    assert(token_equal(lexer_next(&l), SK_NUMBER, 8, 3));
    assert(token_equal(lexer_next(&l), SK_COMMENT, 11, 4));
}

fn test_lexer_rawstrings() {
    let l lexer = lexer_new(str_new("\\foo\n\\quux"));
    assert(token_equal(lexer_next(&l), SK_RAWSTRING, 0, 4));
    assert(token_equal(lexer_next(&l), SK_WS, 4, 1));
    assert(token_equal(lexer_next(&l), SK_RAWSTRING, 5, 5));
}

struct syntaxchild {
    istoken bool,
    kind char,
    range range,
    next *syntaxchild,
    child *syntaxchild,
    parent *syntaxchild,
}

struct syntaxtree { root *syntaxchild }

struct syntaxbuilder {
    root *syntaxchild,
    current *syntaxchild,
    inputidx int,
}

fn syntaxbuilder_new() syntaxbuilder {
    let b syntaxbuilder;
    b.root = 0;
    b.current = 0;
    b.inputidx = 0;
    return b;
}

fn syntaxbuilder_startnode(b *syntaxbuilder, kind char) {
    let new syntaxchild;
    new.istoken = false;
    new.kind = kind;
    new.range.start = b->inputidx;
    new.range.len = 0;
    new.next = 0;
    new.child = 0;
    new.parent = b->current;

    let newallocated *syntaxchild = malloc(sizeof(syntaxchild));
    *newallocated = new;

    if b->current == 0 {
        b->current = newallocated;
        b->root = newallocated;
    } else {
        syntaxchild_addchild(b->current, newallocated);
        b->current = newallocated;
    }
}

fn syntaxbuilder_addtoken(b *syntaxbuilder, kind char, len int) {
    let child *syntaxchild = malloc(sizeof(syntaxchild));
    child->istoken = true;
    child->kind = kind;
    child->range.start = b->inputidx;
    child->range.len = len;
    child->next = 0;
    child->child = 0;
    child->parent = b->current;
    syntaxchild_addchild(b->current, child);
    b->inputidx += len;
}

fn syntaxbuilder_finishnode(b *syntaxbuilder) {
    b->current->range.len = b->inputidx - b->current->range.start;
    b->current = b->current->parent;
}

fn syntaxbuilder_finish(b syntaxbuilder) syntaxtree {
    let t syntaxtree;
    t.root = b.root;
    return t;
}

fn syntaxchild_addchild(c *syntaxchild, newchild *syntaxchild) {
    let placetoinsert **syntaxchild = &c->child;
    for {
        if *placetoinsert == 0 { break; }
        let c *syntaxchild = *placetoinsert;
        placetoinsert = &c->next;
    }
    *placetoinsert = newchild;
}

fn syntaxtree_print(t syntaxtree, text *char) {
    let indentation int = 0;
    let current syntaxchild = *t.root;

    for {
        let i int = 0;
        for {
            if i == indentation { break; }
            printf("\x1B[90mâ”‚\x1B[0m ");
            i += 1;
        }

        syntaxkind_print(current.kind);
        printf(" ");
        range_print(current.range);

        if current.istoken {
            printf(" \x1B[35m\"");
            let s str;
            s.data = text + current.range.start;
            s.len = current.range.len;
            printf("\x1B[95m");
            str_print(s);
            printf("\x1B[35m\"");
        }

        printf("\x1B[0m\n");

        if current.child == 0 {
            let c syntaxchild = current;
            for {
                if c.next != 0 { break; }
                if c.parent == 0 { return; }
                c = *c.parent;
                indentation -= 1;
            }
            current = *c.next;
        } else {
            current = *current.child;
            indentation += 1;
        }
    }
}

fn syntaxtree_format(t syntaxtree, text *char) str {
    let s str;
    s.data = malloc(1024);
    s.len = 0;

    let indentation int = 0;
    let current syntaxchild = *t.root;

    for {
        let i int = 0;
        for {
            if i == indentation { break; }

            *(s.data + s.len) = ' ';
            s.len += 1;
            *(s.data + s.len) = ' ';
            s.len += 1;

            i += 1;
        }

        let kind str = syntaxkind_format(current.kind);
        memcpy(s.data + s.len, kind.data, kind.len);
        s.len += kind.len;

        *(s.data + s.len) = ' ';
        s.len += 1;

        let n int = sprintf(
            s.data + s.len,
            "%d..%d",
            current.range.start,
            current.range.start + current.range.len
        );
        s.len += n;

        if current.istoken {
            *(s.data + s.len) = ' ';
            s.len += 1;

            *(s.data + s.len) = '"';
            s.len += 1;

            memcpy(
                s.data + s.len,
                text + current.range.start,
                current.range.len
            );
            s.len += current.range.len;

            *(s.data + s.len) = '"';
            s.len += 1;
        }

        *(s.data + s.len) = '\n';
        s.len += 1;

        if current.child == 0 {
            let c syntaxchild = current;
            for {
                if c.next != 0 { break; }
                if c.parent == 0 { return s; }
                c = *c.parent;
                indentation -= 1;
            }
            current = *c.next;
        } else {
            current = *current.child;
            indentation += 1;
        }
    }

    return s;
}

fn test_syntax() {
    printf("    test empty\n"); test_syntax_empty();
    printf("    test addtoken\n"); test_syntax_addtoken();
    printf("    test root\n"); test_syntax_root();
    printf("    test links\n"); test_syntax_links();
    printf("    test format\n"); test_syntax_format();
}

fn test_syntax_empty() {
    let b syntaxbuilder = syntaxbuilder_new();
    syntaxbuilder_startnode(&b, 0);
    syntaxbuilder_finishnode(&b);
    syntaxbuilder_finish(b);
}

fn test_syntax_addtoken() {
    let b syntaxbuilder = syntaxbuilder_new();
    syntaxbuilder_startnode(&b, SK_ROOT);
    syntaxbuilder_addtoken(&b, SK_FORKW, 3);
    syntaxbuilder_finishnode(&b);
    syntaxbuilder_finish(b);
}

fn test_syntax_root() {
    let b syntaxbuilder = syntaxbuilder_new();
    syntaxbuilder_startnode(&b, SK_ROOT);
    syntaxbuilder_addtoken(&b, SK_WS, 1);
    syntaxbuilder_addtoken(&b, SK_WS, 1);
    syntaxbuilder_finishnode(&b);
    let t syntaxtree = syntaxbuilder_finish(b);
    let root syntaxchild = *t.root;
    assert(range_equal(root.range, 0, 2));
    assert(root.kind == SK_ROOT);
}

fn test_syntax_links() {
    let b syntaxbuilder = syntaxbuilder_new();
    syntaxbuilder_startnode(&b, SK_ROOT);
    syntaxbuilder_startnode(&b, SK_FUNCTION);
    syntaxbuilder_addtoken(&b, SK_FNKW, 2);
    syntaxbuilder_addtoken(&b, SK_IDENT, 1);
    syntaxbuilder_finishnode(&b);
    syntaxbuilder_startnode(&b, SK_FUNCTION);
    syntaxbuilder_addtoken(&b, SK_FNKW, 2);
    syntaxbuilder_addtoken(&b, SK_IDENT, 1);
    syntaxbuilder_finishnode(&b);
    syntaxbuilder_finishnode(&b);
    let t syntaxtree = syntaxbuilder_finish(b);
    let root syntaxchild = *t.root;

    let node1 syntaxchild = *root.child;
    assert(node1.kind == SK_FUNCTION);
    assert(range_equal(node1.range, 0, 3));

    let node1child1 syntaxchild = *node1.child;
    assert(node1child1.kind == SK_FNKW);
    assert(range_equal(node1child1.range, 0, 2));

    let node1child2 syntaxchild = *node1child1.next;
    assert(node1child2.kind == SK_IDENT);
    assert(range_equal(node1child2.range, 2, 1));

    assert(node1child2.next == 0);

    let node2 syntaxchild = *node1.next;
    assert(node1.kind == SK_FUNCTION);
    assert(range_equal(node2.range, 3, 3));

    let node2child1 syntaxchild = *node2.child;
    assert(node1child1.kind == SK_FNKW);
    assert(range_equal(node2child1.range, 3, 2));

    let node2child2 syntaxchild = *node2child1.next;
    assert(node1child2.kind == SK_IDENT);
    assert(range_equal(node2child2.range, 5, 1));

    assert(node2child2.next == 0);

    assert(node2.next == 0);
}

fn test_syntax_format() {
    let b syntaxbuilder = syntaxbuilder_new();
    syntaxbuilder_startnode(&b, SK_ROOT);
    syntaxbuilder_startnode(&b, SK_FUNCTION);
    syntaxbuilder_addtoken(&b, SK_FNKW, 2);
    syntaxbuilder_addtoken(&b, SK_IDENT, 1);
    syntaxbuilder_finishnode(&b);
    syntaxbuilder_startnode(&b, SK_FUNCTION);
    syntaxbuilder_addtoken(&b, SK_FNKW, 2);
    syntaxbuilder_addtoken(&b, SK_IDENT, 1);
    syntaxbuilder_finishnode(&b);
    syntaxbuilder_finishnode(&b);
    let t syntaxtree = syntaxbuilder_finish(b);

    assert(str_equal(
        syntaxtree_format(t, "fnafnb"),
        \ROOT 0..6
        \  FUNCTION 0..3
        \    FNKW 0..2 "fn"
        \    IDENT 2..3 "a"
        \  FUNCTION 3..6
        \    FNKW 3..5 "fn"
        \    IDENT 5..6 "b"
        \
    ));
}
